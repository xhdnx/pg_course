## Настройте сервер так, чтобы в журнал сообщений сбрасывалась информация о блокировках, удерживаемых более 200 миллисекунд. Воспроизведите ситуацию, при которой в журнале появятся такие сообщения.

	В postgres.conf изменяем следующие параметры
	

> 	log_lock_waits = on    # log lock waits >= deadlock_timeout
> 	deadlock_timeout = 200ms

	Необходимо выполнить рестарт кластера, чтобы изменения вступили в силу. Проверяем значения через psql
	

> 	postgres=# show log_lock_waits; 	 log_lock_waits  	---------------- 	
> on 	(1 row)
> 
> 	postgres=# show deadlock_timeout; 	 deadlock_timeout 
> 	------------------ 	 200ms 	(1 row)


## Смоделируйте ситуацию обновления одной и той же строки тремя командами UPDATE в разных сеансах. Изучите возникшие блокировки в представлении pg_locks и убедитесь, что все они понятны. Пришлите список блокировок и объясните, что значит каждая. 

Изображение 8_1

Описание типов блокировок и процессов которые их порождают:
 - Блокировка отношения 12290 и virtualxid - процессы порожденные вызовом системного представления pg_locks. Своего рода это тоже транзакция которая требует некоторого обращения к ресурсу, а следовательно и вешает блокировки.
 - Блокировку типа tuple можно представить как процесс ожидающий пока освободится строка таблицы, чтобы выполнить свои изменения. На рисунке видно что у нас две блокировки типа tuple - соответствуют двум транзакциям из других сессий.
 - SharedLock с доступом f - говорит что сессия с pid 41152 (вторая по очереди) является следующим процессом который получит доступ к ресурсу после его освобождения первой транзакцией
 
##  Воспроизведите взаимоблокировку трех транзакций. Можно ли разобраться в ситуации постфактум, изучая журнал сообщений?
Воспроизведем взаимоблокировку трех сессий следующей последовательностью действий ()
Сессия №1 : begin; update accounts set amount = amount + 100 where acc_no = 2; --блокируем запись 2
Сессия №2 : begin; update accounts set amount = amount + 100 where acc_no = 1; --блокируем запись 1
Сессия №3 :  begin; update accounts set amount = amount + 100 where acc_no = 3; --блокируем запись 3
Сессия №2 :  begin; update accounts set amount = amount + 100 where acc_no = 2; -- встаем в ожидание записи 2
Сессия №3 :  begin; update accounts set amount = amount + 100 where acc_no = 1; -- встаем в ожидание записи 1
Сессия №1 : begin; update accounts set amount = amount + 100 where acc_no = 3; -- замыкаем цепочку последним ожиданием

Получаем следующий текст на первой сессии:

Изображение 8_2

Анализируя системное представление pg_stat_activity сессии которые привели к возникновению deadlock не смог определить. По полю "state" видно что сессия №1 закончилась с ошибкой; сессия №2 закончила выполнение команд, но не завершила транзакцию; сессия №3 является активной, т.к. ожидает освобождения блокируемого сессией№2 ресурса. 

Изображение 8_3
Изображение 8_4
Изображение 8_5



##   Могут ли две транзакции, выполняющие единственную команду UPDATE одной и той же таблицы (без where), заблокировать друг друга?

Изображение 8_6

Да. Это можно видеть по записям в журнале событий. Одна транзакция активна - ожидает выполнения. Другая закончила изменение данных, но продолжает держать блокировку на ресурсе.